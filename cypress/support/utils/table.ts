import { DataTable } from "@badeball/cypress-cucumber-preprocessor";
import lodash from "lodash";
import random from "random-seed";
import _ from "underscore";

function getCacheValue(context: object, key: string): unknown {
    return context[key];
}

/**
 * Checks whether passed string is integer number.
 */
function isInteger(str: string) {
    return /^\d+$/.test(str);
}

/**
 * Evaluates expression from passed string.
 * See https://www.jayway.com/2012/04/03/cucumber-data-driven-testing-tips/ for more information.
 * The rules are:
 *  - ${} – everything inside will be parsed, strings are comma separated
 *  - numerical value – create random alphanumeric string
 *  - ! – use the string as it is
 *  - N – random numbers
 *  - d - date in
 * Math.random().toString(36) is used to generate random string.
 */
function evalExpression(str: string) {
    if (isInteger(str)) {
        /**
         * Seed is generated by timestamp + random string.
         * Additional random string is required, because using only seed for generating string in loop
         * will cause random string duplication.
         */
        const seed = new Date().getTime().toString() + Math.random().toString(36);
        const rand = random.create(seed);
        const alphabet = "abcdefghijklmnopqrstuvwxyz";
        const randomLetter = alphabet[Math.floor(rand.random() * alphabet.length)];
        // !!!IMPORTANT Random letter is required in generated string because of
        // issue https://exabyte.atlassian.net/browse/SOF-1719
        // Generated string is used for username generation. In case of random string contains only numbers
        // slug for default issue will be inappropriate (e.g., "user-1232" has "user" slug).
        return (
            randomLetter +
            rand
                .random()
                .toString(36)
                .substring(2, 2 + parseInt(str) - 1)
        );
    }
    if (str.indexOf("!") === 0) {
        // ! – use the string as it is
        return str.substring(1);
    }
    if (str.indexOf("N") === 0) {
        // random numbers
        let result = "";
        const max = 9;
        const min = 0;
        const count = parseInt(str.substring(1));
        let i = 0;
        for (; i < count; i++) {
            result += Math.floor(Math.random() * (max - min + 1)) + min;
        }
        return result;
    }
    return "";
}

/**
 * Parses passed string and returns evaluated value.
 */
export function parseValue(str: string, context: object) {
    if (!_.isString(str)) throw new Error("Argument should be string");
    // eslint-disable-next-line no-shadow, no-use-before-define
    const config = REGEXES.find((config) => str.match(config.regex));
    return config ? config.func(str, config.regex, context) : str;
}

/**
 * @summary Parses values from table rows. Each column's value for each row are parsed by parseValue.
 * @param table Table passed from Cucumber step definition.
 * @param context  Context for extracting cached values.
 */
export function parseTable<T>(table: DataTable, context: object = {}): T[] {
    return table
        .hashes()
        .map((hash) => _.mapObject(hash, (value) => parseValue(value, context)) as T);
}

interface Basis {
    elements: {
        id: number;
        value: string;
    }[];
    coordinates: {
        id: number;
        value: number[];
    }[];
    units: "crystal";
}

/**
 * Parses basis string in format "Si 0 0 0, Li 0.5 0.5 0.5" and returns it as an object in exabyte internal format.
 */
function parseBasisStr(str: string) {
    const lines = str.split(/[,;]/).map((x) => x.trim());
    const basis: Basis = {
        elements: [],
        coordinates: [],
        units: "crystal",
    };
    for (let i = 0; i < lines.length; i++) {
        const items = lines[i].split(" ") as [string, string, string, string];
        basis.elements.push({
            id: i + 1,
            value: items[0],
        });
        basis.coordinates.push({
            id: i + 1,
            value: [items[1], items[2], items[3]].map(parseFloat),
        });
    }
    return basis;
}

interface Regex {
    name: string;
    regex: RegExp;
    func: (str: string, regex: RegExp, context: object) => unknown;
}

function matchRegexp(str: string, regex: RegExp): string {
    const match = str.match(regex);
    if (!match) {
        throw new Error("DATE_REGEX REGEX ERROR");
    }
    return match[1];
}

const REGEXES: Regex[] = [
    {
        name: "DATE_REGEX",
        regex: /^\$DATE\{(.*)}/,
        func: (str, regex) => new Date(matchRegexp(str, regex)),
    },
    {
        name: "BOOLEAN_REGEX",
        regex: /^\$BOOLEAN\{(.*)}/,
        func: (str, regex) => JSON.parse(matchRegexp(str, regex)),
    },
    {
        name: "ARRAY_REGEX",
        regex: /^\$ARRAY\{(.*)}/,
        func: (str, regex) => matchRegexp(str, regex).split(","),
    },
    {
        name: "INT_REGEX",
        regex: /^\$INT\{(.*)}/,
        func: (str, regex) => parseInt(matchRegexp(str, regex)),
    },
    {
        name: "FLOAT_REGEX",
        regex: /^\$FLOAT\{(.*)}/,
        func: (str, regex) => parseFloat(matchRegexp(str, regex)),
    },
    {
        name: "BASIS_REGEX",
        regex: /^\$BASIS\{(.*)}/,
        func: (str, regex) => parseBasisStr(matchRegexp(str, regex)),
    },
    {
        name: "EXPR_REGEX",
        regex: /^\$\{(.*)}/,
        func: (str, regex) => {
            return matchRegexp(str, regex)
                .split(",")
                .map(evalExpression)
                .reduceRight((mem, part) => part + mem, "");
        },
    },
    {
        name: "CACHE_REGEX",
        // eslint-disable-next-line no-useless-escape
        regex: /\$CACHE\{([^\{^}]*)}/,
        func: (str, regex, context) => {
            const value = matchRegexp(str, regex);
            const [contextKey, property] = value.split(":");
            return parseValue(
                str.replace(
                    `$CACHE{${value}}`,
                    lodash.get(getCacheValue(context, contextKey), property),
                ),
                context,
            );
        },
    },
];
